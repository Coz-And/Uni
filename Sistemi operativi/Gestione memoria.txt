Gestione della memoria
il sistema operativo svolge il duplice ruolo di : 
        - Gestore delle risorse --> decide quali risorse assegnare ai diversi processi
        - Controllare : assicura che le risorse assegnate ad un altro processo non possano essere usate / alterate dagli altri processi 
le risorse da assegnare ai processi vi é la memoria che dovrebbe 
     1. Ampia 
     2. Veloce
si può avere tutto, perciò si usa una gerarchia di memorie : 
        1. Cache :  memoria di capacità ridotta, molto veloce e costosa
        2. Ram: Memoria di capacitò dell'ordine di alcuni GB, velocità media e prezzo medio
        3. Dischi : centiania di GB di memoria ad alta capacitò, più lenta ed economica.

e |                                                         ^ e
t |                                                         | t 
n |                                                         | n
e |                                                         | e 
c |                                                         | c 
s |                                                         | s 
e |                                                         | e 
r |                                                         | r 
c |                                                         | c
  |                                                         | 
à |                                                         | a
t |                          Registrers                     | t
i |                            Cache                        | i
c |                          Main Memory                    | c
a |                         Magnetic disck                  | o   
p |                         Magnetic Tape                   | l   
a |                                                         | E
c >                                                         | V

la gerarchia della memoria consiste nel portare verso il vertice della piramide le informazioni più usate dalle prozioni di programma in esecuzione
la maggior parte dei casi il tempo di accesso coincide con quello delle memorie più rapide.

l'aggiornaemnto del contenuto della cache è gestito per lo più in hardware. se l'hit rate é alto, si ha un tempo medio di accesso alla memoria intermedio 
tra quello della RAM e quello della cache

Indirizzi logici e fisici 
allocare liberamente i processi in memoria (RAM) occorre distinguere tra indirizzi logici e indirizzi fisici, il binding (Associazione), tra indirizzi logici
e indirizzi fisici può avvenire in momenti diversi : 
la compilazione, durante il caricamento oppure run-time, il più flessibile, in questo caso nel file eseguibile c'è un indirizzo. é un indirizzo logico e una volta caricato il programma
in RAM, gli indirizzi degli operandi, delle istruzioni, i valori delle variabili puntatore, tutti gli indirizzi generati dal programma sono indirizzi logici.

MMU (Memory Management UNIT) si occupa di operare la traduzione al momento dell'accesso in memoria (da logico a fisico).

Rilocabilità e protezione dei sistemi multiprogrammati
- Allocazione contigua dell'immagine del processo
- Un registro base e registro limite

LA MMU svolge in hardawre la funzione  :
 if (base + ind_logico >Limite) then
    trap("Segmentation Fault")
  else ind_fisico = Base + ind_gioco

oltre alla traduzione logico-fisico permette di confinare un prorcesso allo spazio ad esso assegnato garantendo cosi la protezione del sistema operativo e degli altri processi.

i registri limit e base possono essere modificati solo in modo kernel, la traduzione indirizzo logico_indirizzo fisico e il controllo di non superamento dei limiti viene fatta dalla MMU
il valore base e limite di ogni processo sono memorizzati nel PCB.

Allocazione spazio in memoria : partizioni fisse
Gestione dello spazio in RAM  nei registri multiprorgrammati: i job sottoposti al sistema sono caricati su disco; se ne tiene traccia in una cosa, caricandoli in memoria quando si libera una partizione,
la suddivisione in partizioni é configurata dal sistema all'avvio del sistema.
le code possono essere separate per partizioni o congiunte.
possiamo trovare uno spreco di memoria, in particolare Frammentazione interna : parte della memoria assegnata a un processo non é utilizzata. 
una politica di assegnazione delle partizioni ai job.

Partizioni variabili
Una gestione un'pò flessibile, uno spazio libero contiguo abbastanza grande, si carica processo, con la creazione o terminazione di processi si creano dei buchi non contigui di grandezza variabile.
verificarsi una situazione in cui un nuovo processo deve essere creato, in totae ci sarebbe abbastanza memoria per caricalo, é la formula da molti frammenti non contigui: si ha frammentazione esterna, troppompiccoli per essere utilizzati 

Come affrontare la frammentazione esterna :
- Effettuare periodicamente una compattazione della memoria
- Utilizzare il disco come "deposito temporaneo" di processi effettuando lo swapping: lo swap out di un processo per fare spazio ad uno nuovo lo swap in queando si libera nuovamente dello spazio.

Processi a dimensione variabile
ci sono Strutture dati che possono crescere, conviene allocare fin dall'inizio più spazio di quanto richiesto inizialmente, si eccede anche quello, o c'è un nuco contiguo, oppure devo spostare il processo in uno spazio più grande, o ancora fare swap out.

Algoritmi di allocazione nello spazio con partizioni variabili

- First Fit : il primo abbastanza a partire dall'inizio della lista degli spazi liberi
- Next Fit : il primo grande abbastanza a partire dal punto della lista dove si era fermata l'ultima ricerca
- Best Fit : lo spazio che meglio si adatta alla dimensione del proceso, evita occupare spazi grandi che potrebbero servire dopo per allocare processi più grandi. crea rimanenze piccole per essere utilizzate
- Worst Fit : lo spazio che peggio si adatta alle dimensioni del processo, serve per lasciare spazi abbastanza grandi da essere utilizzabili

Algoritmo di allocazione : 
Esempio
sono presenti i seguenti spazi liberi : 
100K, 500K, 200K, 300K, 600K, come verrebbero allocati i seguenti processi : p1(212k),p2(417K),p3(112K),P4(426K)

First Fit: P1 in 500K (rimane 228K), P2 in 600K (rimane 183K), P3 in 288K (176K), p4 deve attendere

Best Fit: P1 in 300 K (rimane 88K), P2 in 500K (rimane 83K), P3 in 200K (rimane 88K), P4 in 600K (174K)

Worst Fit : P1 in 600k (rimane 388K), P2 in 500K (rimane 83K), P3 in 388K (rimane 276K), P4 deve attendere

Allocazione non contigua 
Schemi alternativi di allocazione dei processi, in memoria prevedono di poter suddividere l'immagine di un processo in porzioni : 
- dimensione qualsiasi 
- Dimensione predefinita

Segmentazione : l'immagine del processo è costituita da N spazi linerai di indirizzi, l'indirizzo logico é formato da una coppia
Paginazione : l'immagine del processo é costituita da N pagine di dimensione prefissata. l'indirizzo é in un unico spazio indirizzi , può essere composto in numero di pagina, offset
Vengono  allocati in memoria in posizioni non necessariamente contigue, l'utilizzazione delle memoria  : 
        - la segmentazione c'è frammentazione esterna, in misura minore rispetto all'allocazione contigua, faicle trovare posto per un segmento che per un intero processo 
        - la paginazione c'è fremmentazione interna, ma limitata a mezza pagina per processo .

la memoria virtuale 
il disco per contenere l'intera immagine del processo e caricare in RAM solo una parte dell'immagine del processo, quella effettivamente utile alla sua esecuzione nella fase attuale, RAM si può mantenere una porzione più grande del processo di quanta se ne tiene in cache.
lo spostamento da disco a ram e viceversa a blocchi.
permette di eseguire uno o più processi la cui dimensione, o la somma delle cui dimensioni, é maggiore di quelal dalla RAM.
parti dell'immagine di un processo possono, in un'alta percentutale delle esecuzioni del programma, non essere mai necessarie : 
        - ruotine che vengono chiamate raramente : funzionalità di un programma utilizzate poco di frequente dall'utente, ruotine di gestione di errori
        - Strutture Dati, allocate di grandi dimensioni ma, in molte esecuzioni, utilizzate soltato per una piccola parte 
la memoria virtuale su richiesta è sufficiente a caricare solo le pagine utilizzate.

La memoria virtuale 
é il fenomeno della località dei riferimenti alla memoria : per periodi significativamente lunghi, tipicamente un processo :
        - Accede ripetutamente ad indirizzi in un sottoinsieme delle sue pagine (working set)
        - Accede ripetutamente agli stessi indirizzi : Variabili usate ripetutamente, parti di codice usate ripetutamente
        - Accedere a indirizzi vicini a quelli usati poco prima : codice sequenziale, Spazzolare Array, per i loop si eseguono più volte istruzioni fra loro vicine.
        - non accede a quelli di altre pagine, che quindi possono non stare in memoria.
La località
Pagine servono ci baseremo sul passato, supponendo di non essere nei momenti di transizione, il cigno ner, l'autore Nassim Nicholas Taleb presente la storia di un tacchino nutrito dagli umani, supponiamo di misurare il suo benessere o difucia negli essere umani.
Fortuna nel rimpiazzamneto delle pagine non siamo come quel tacchino: se i momenti di transizione, della località sono davvero pochi, a quelli sopravviveremo, al costo di rimpiazzare un pò di pagine.

La memoria virtuale
é proprio la necessità di eseguire programmi che richiedono più spazio della RAM disponibile, Sistemi "primitivi" questo si realizzava permettendo ai programmatori di spezzare codice e dati di un programma in "Sezionni" chiamate overlay,
il sistema operativo forniva la possibilità di rimpiazzare un overlay con un altro durante l'esecuzione.
lo svantaggio di questo apprioccio è che la gestione degli overlay é a carico del programmatore

La tecnica di paginazione su richiesta, svolge in aumatico, in modo completamente trasparente per il programamtore.
un sistema multiprogrammato tali tacniche permettono anche di mantenere in memoria un insieme di processi che complessivamente occuperebbero più spazio della memoria RAM disponibile.
        1. L'immagine in memoria di ciascun processo viene suddivisa in blocchi di ugauale dimensione chiamati pagine.
        2. La memoria fisica viene suddivisa in frame della stessa dimensione delle pagine logiche
        3. Processo viene mantenuto una tabella delle pagine, che indica per ciascuna pagina dello spazio di indirizzi del processo se si trova o meno in memoria RAM, e in quele framme.
           Occorre inoltre tenere traccia della posizione delle pagine logiche su disco.
        4. PAginazione senza memoria virtuale tutte le pagine devono essere caricate in RAM, con memoria virtuale.

Esempio 
Lo spazio di indirizzi del processo P1 comprende 16 pagine logiche da 4Kbyte ciascuna (4K * 16 2^16 byte)
La RAM ha solo 8 frame  : la figura mostra una situazione in cui sono caricate in RAM le pagine logiche 0, 1, 2, 3, 4, 5, 9, 11 del processo rispettivamente nei frame 2, 1, 6, 0, 4, 3, 5, 7
La pagine logiche possono essere caricate in frame non consecuitivi, e in ordine sparso
traccia in una tabella delle pagine.

Traduzione da indirizzo logico a indirizzo fisico
Deve eseguire LA MMU per tradurre gli indirizzi logici (IL) in indirizzi fisici (IF).
l'operazione da fare sarebbe : 
  1. Calcolo numero di pagine logica (NP) e offset (o) : 
                NP = IL / DimPag; O = il % DimPag
        /*Quoziente e resto della divisione intera*/
   Quoziente e restp della divisione intera 
        DimPag * NP + O; con O < dimPag 
  2. if(TabPag[NP].Present == 0) then trap (page fault)
      else NF = TabPag[NP].frame
  3. Indirizzo fisico IF = indirizzo Frame NF + O = DimPag * Nf + o

Trattaemento dei page fault
Solo un sottoinsieme della pagine è presente in memoria, si può verificare un accesso ad una pagina non caricata :  in questo caso MMU genera una trap di tipo apge fault, la cui gestione é :
     1. Cerca un frame libero in RAM : se non c'è, si sceglie una pagina vittima
     2. il frame selezionata viene etichettato busy in modo che venga scelto di nuovo come vittima
     3. se necessario su disco
     4. si carica la pagina che ha causato il page fault da disco a RAM, mentre la pagina viene caricata, la CPU può essere data ad un altro processo;
     5. l'interruzione da disco dice che la pagina é caricata, si aggiorna la tabella delle apgine, e si rimette il processo pronto; quando girerà eseguirà di nuovo l'istruzione che ha causato il page fault.

Traduzione degli indirizzi 
non c'è bisogno di usare hw in grado di fare divisioni e moltiplicazioni se DimPag = 2^K; se supponiamo che il numero di bit dell'IL sia m e il numero di bit nell'indirizzo fisico sia Fault
gli m-k bit più significativi di IL e i K bit meno significativi sono quozionete e resto della divisione 2^K, e per ottenere 2^K * NF + O basta gistaporre i bit.
8196 / 4096 = 2, con resto 4, in binario é 
        
        001000000000100 /
           100000000000 =
                   0010
Resto 100
in questo caso la pagina  0010, vale a dire 2, é presente e si trova nel frame 110, vale a dire 6, allora : 

             100 * 
   1000000000000 =
 100000000000000 +
             100 =
 100000000000100

Trattamento dei page fault 
Un sottoinsieme della pagine é presente in memoria, si può verificare un accesso ad una pagina non caricata :  questo caso la MMU genera una trap di tipo page fault, la cui gestione é :
    1. Cerca un frame libero in RAM : se non c'è, si sceglie una pagina vittima
    2. il frame selezionato viene etichcettato busy in modo che non venga scelto di nuovo come vittima
    3. se necessario su disco 
    4. si carica la pagina che ha causato il page fault da disco a RAM; mentre la pagina viene (salvata) caricata, la CPU può essere fata ad un altro processo
    5. l'interruzione da disco dice che la pagina è caricata, si aggiorna la tabella della pagine, e si rimette il processo pronto; quando girerà eseguirà di nuovo l'istruzione che ha causato il page fault

Traferimento delle pagine da disco a RAM        
Viene creato il processo, viene allocato lo spazio per la sua immagine sulla baking store, poi le pagigne vengono caricate in RAM secondo necessità. le operazioni di swap-in delle pagine avvengono su richiesta durante l'esecuzione del processo, cioé in seguita ad un page fault
durante una fase di prepaging attivata dal sistema oeprativo prima di rendere running un processo. 

le operazioni di swap-out delle pagine avvengono quando si deve liberare spazio per nuove pagine, conviene che l'hardware fornisca traccia in un bit per ogni pagina, sono state effettivemnte modificate dall'utlimo caricamento,
al momento del rimpiazzamento copiare su disco la pagina rimpiazzata solo se il suo dirty bit vale 1.

Il rimpiazzamento delle pagine
Gestire una trap di tipo page fault il sistema oeprativo deve : 
        - scegliere un frame in cui caricare la pagina; uno libero, se c'è oppure uno che contiene una pagina che si spera vada bene rimpiazzare
        - leggere da disco la pagina mancante e caricarla nel frame scelto

l'algoritmo di rimpiazzamento che sceglie la pagian da ogni page fault deve cercare di minimizzare il numero  di page fault, ne sono stati considerati tanti
        - Ottimale 
        - Least Recently Used (LRU) 
        - Not Recently Used (NRU)
        - FIFO
        - seconda possibilità o dell'orologio

Rimpiazzamento delle pagine
le prestazioni dei diversi algoritmi di rimpiazzamneto si confrontano i numeri di page fault che si ottengono applicandoli a un insieme di stringhe di riferimenti alla memoria.
tale stringa di riferimenti, alla memoria, Stringa può essere data come  : 
        - lista di indirizzi generata deall'eseccuzione di un processo o lista di pagine logiche.
        - Eventualemnte corredati dall'indicazione del tipo di accesso

Solo processo o per processi diversim perché in un sistema multiprogramamto si possono usare due approcci al rimpiazzamento
        1. Locale --> ad ogni processo viene assegnato un numero di frame definito, quando P1 causa un page fault, la vittima per il rimpiazzamento può essere scelta solo tra le pagine di p1
        2. Globale --> la vittima per il rimpiazzamento può essere scelta fra tutte le pagine in memoria

il rimpiazzamento delle pagine
Ogni momento in memoria vi fosse l'intero working set (WS) di ogni processo, informalmente: l'insieme di pagine necessarire al processo in quella fase delal sua esecuzione, ricordiamo la località, nel tempo e nello spazio
quindi ci si basa sul passato, supponendo di non essere nei momenti di transizione, se davvero sono pochi , il costo é accettabile fissato un numero k di riferimenti da considerare, il working set del processo in un dato istante della sua esecuzione può essere definito come, l'insieme di pagine
utilizzate negli utenti k riferimenti alla memoria.

Una finestra temporale di ampiezza t utnia di tempo definendo il working set come l'insieme di pagine riferite nelle ultime t unità di tempo di esecuzione.
