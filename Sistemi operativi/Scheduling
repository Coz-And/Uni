Sistema di elaborazione diverse code : 
    1. Coda dei job [i proccessi di cui é richiesta l'esecuzione]
    2. Coda dei processi ready [insieme dei processi caricati in memoria e pronti ad usare la CPU]
    3. Code dei dispositivi [Insieme delel richieste di I/O pendenti per i diversi dispositivi]
 
i processi migrano da una coda all'altr nel coro della loro vita

pagina 2 

Tipi di scheduler

Long-term --> scheduler [decide quali job portare in ready queue] (Job scheduler)
short-term --> Scheduler [selezione il prossimo processo a cui assegnare la CPU (deve oeprare velocemente, CPU scheduler)]
Medium-term --> regola il livello di multiprogrammazione (Tramite swap-in / swap-out) in base alle risorse disponibili, in particolare la memoria

pagina 4-5

Obiettivi dello scheduling 
Generali:
    - Assegnare il tempo di CPU ai processi in modo "equo"
    - mantenere le risorse del sistema utilizzate
Sistema a lotti
    - Massimizzare il Throughput
    - minimizzare il tempo medio di turnaround
Sistemi interattivi:
    - Minimizzare il tempo di risposta 
    - soddisfare le richieste introducendo attese piccole o comunque in proporzione al tempo effettivo di esecuzione.
Sistemi Real-time
    - Rispettare le scadenze, sempre o con poche eccezioni per non degradare la qualità servizio.

Mix di processi da sottoporre allo short-term scheduling
l'uso efficiente delel risorse è possibile sfruttando le diverse caratteristiche dei processi : conviene avere un mix bilanciato di processi CPU buond(a) e I/O bound(b)

scheduling della CPU : [Quando]
la decisione su qual è il prossimo processo da rendere running fra quelli pronti(Ready) può/deve avvenire : 
        - il processo running termina
        - il processo running effettua un'operazione sospensiva 
        - viene creato un nuovo processo 
        - c'è interrupt da disp.I/O
        - c'è interruzione da timer

Deve avvenire nei primi due casi, quando il processo running rilasciata volontaria la CPU, ultimi tre casi, viene chiamato in causa il S.O che toglie la risorsa CPU al processo running si ha PREEMPTION.

Rappresentazione scelte dello scheduler
i diagrammi di GANTT per rappresentare le scelte fatte da un dato algoritmo di shceduling in un data situazione, a partire dal GANTT potrebbe calcolare:
    - il tempo di attesa di ciascun processo
    - il tempo di permanenza di ciascun processo 
    - il tempo medio di attesa e di permanenza per l'insieme dei processi considerati 
quindi sarà possibile confrontare le prestazoni di ciascun algoritmo sulla base di tali tempi


scheduling per sistemi batch 
Vengono sottoposti diversi job, e supponiamo vengano eseguiti fino a completamento : 
        First -come First-saved
        Shortest hob first : richiede di conoscere la durata dei job

Scheduling per sistemi batch
i job arrivano contemporanemaente, sJF é ottimale, infatti se x1, è la durata del primo processo che ha ottenuto la PCU, X2quella del secondo, il tempo medio di turnaround (X1 <= x2<= x3<= x4 ),
SJF si può applicare anche se i job non arrivano contemporanemente.
Esempio : 
    A, B, C, D, E arrivano all'istante 0,0,3,3,3, rispettivamente e richiedono rispettivamente 2,4,1,1,1, unità di tempo di computazione SJF schedulerebbe A,B,C,D,E che non  é ottimale.
per tener conto dell'arrivo distribuito nel tempo si può usare una versione modificata di SJF : 
                            Shortest Remaining Time Next
Questo algoritmo è preemptive : può togliere la CPU a chi é running quando arriva un nuovo job

si fa a conoscere la durata di un job, per applicare SJF o SRTN nello scheduling, nei sistemi batch, quando si sottopone un job si fornisce anche una sovrastimata del tempo di elaorazione, che viene usata come tempo limite : se viene superato, il job non viene completato.

Problema 
SJF e SRTN : un processo può essere sorpassato da processi più corti e non girare mai .

l'idea di SJF e SRTn può essere applicat anche nello scheduling a breve termine, sulla base della durata stimata del prossimo CPU burst.
il processo con il prossimo CPU burst più piccolo, ci serve per avere un tempo medio di risposta piccolo e per anticipare le ristorse richieste ai dispositivi.
infatti al termine di questo CPU burst : 
        - l'utente ottiene presto una risposta e il processo si mette in atessa della reazione.
        - il processo sottopone presto una operazione al dispositivo, la gestione del dispositivo avrà la richiesta presto e potrà mandarla avanti prima ottimizzare la gestione delle richieste

l'utente pensa il dispositivo lavoro, mando aventi processi con CPU burst più lunghi 
la durata del prossimo CPU burst, lo si può fare a partire dai dati relativi ai precendenti CPU-burst attraverso una media esponenziale : 

                                                    Tn+1 = a tn + (1-a)tn
            1. Tn é la durata effettiva dell'n-esimo CPU burst
            2. a é compreso tra 0 e 1 
            3. Tn+1 é la stima dell' n+1 esimo CPU-Burst
            4.To ha un valore predefinito


Scheduling per sistemi interattivi 
il criterio più semplice per i sistemi interattivi è il Ruond Robin : 
il processo corrente è rimasto running per un quanto il tempo, va in fondo alla coda dei processi pronti, veiene scelto il primo 


current process---- ---------next process
                  | |
                  B-F-D-G-A

Durata del quanto : 
    - minimo 10 volte il tempo di context switch, possibile di più (lo switch include anche flush della MMU)
    - non troppo per evitare tempi di risposta alti
    tipicamente tra 10-100 msec.
