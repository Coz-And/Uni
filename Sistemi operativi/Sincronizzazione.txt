Sincronizzazione e comunicazione fra processi /thraed
  per realizzare applicazioni costrituite da più processi o thread cooperanti occorrono meccanismi per : 
      1. Attivazione e terminazione di proecsi / thread
      2. Sincronizzazione : p1 per andare avanti attende che p2 sia arrivato ad un dato punto [utile per disciplinare l'accesso a dati condivisi]
      3. Comunicazione : p2 passa dati a p1 [Tipicamente attende anche nella siconizzazione "Semplice" c'è almeno il passaggio dell'informazione che p2 é arrivato al punto desiderato]
  
  I meccanismi si possono trovare in :
  a. linguaggi concorrenti [dotati di istruzioni apposite per attivare e far sincronizzare / comunicare più processi / thread]
  b. system calls messe a disposizione dal sistema operativo
  c. librerie di funzioni per lo sviluppo di applicazioni concorrenti 


  Modello a memoria condivisa : i processi condividono almeno alcune variabili in memoria, se un processo /thread modifica una di queste variabili, 
  gtutti gli altri processi/thread vedanno il nuovo valore . la condivisione é naturale per threads, per i processi é stata introdotta con meccanismi
  appositi.

  Modello a scambio di messaggi  : i processi non condivisono aree di memoeria, ma possono inviarsi messaggi utilizzando istruzioni sed e receive. lo scambio di messaggi :
  i processi. 


  Sezioni critiche : requisiti per una buona soluzione 
  Una soluzione soddisfacente al problema della mutua esclusione di sezioni critiche deve rispettare i seguenti requisiti : 
    a. Mutua Esclusione se il processo Pi é in esecuzione nella propria sezione critica, nessun altro processo può essere in esecuzione nella propria sezione critica
    b. Progresso se nessun processo è in esecuzione nella propria sezioni critica, e vi sono dei processi che intendono entrare nelle rispettive sezioni critiche, la 
       scelta su chi può procedere dipende solo da quali sono questi ultimi processi, e questa scelta non può essere rimandata indefinitamente.
    c. Attesa limitata un processo Pi ha richiesto di entrare in sezione critica, esiste un limite massimo al numero di volte per cui viene consentito ad altri proessi di 
       entrare nelle rispettive sezioni critiche prima che si accordi l'accesso a pi.

si Assume che ogni processo rimanga in sezione critica per un tempo finito, fare alcuna assunzioni sulla velocità relativa dei processi.

Formulazione Alternativa dei requisiti di una buona soluzione  é  : 
  1. essere garantita la mutua eslcusione nell'esecuzione delle sezioni critiche da parte di tutti i processi coinvolti.
  2. non può basarsi su ipotesi rigurado alle velocità relative di esecuzione dei processi coinvolti e al numero di CPU.
  3. processo che sta eseguendo sezioni non critiche non deve impedire ad altri processi di accedere alla propria sezione critica.
  4. non può accedere che un processo debba attendere indefinitamente il proprio turno di entrare in sezione critica.

  Soluzione dei problemi di mutua eslcusione in sezione critica
  Disibilitazione interrupt
  il motivo per le istruzioni che compongono le sezioni critiche di due processi eseguiti in pseudo-parallelismo possono essere intercalate in modo arbitrario è un processo può 
  essere interrotto durante l'esecuzione, causa dell'arrivo di un timer interrupt.

  problemi di questa soluzione :
  - motivi di protezione non si vuole permettere ad un processo che gira in modalità utnete di disabilitare gli interrupt
  - la soluzione funziona correttamente solo se il sistema ha un'unica CPU : nei sistemi multiprocessore la disabilitazione degli interrupt è locale a ciascuna CPU, e i processi 
    possono eseguire davvero in parallelo.

Non-soluzione dei problemi di sincronizzazione 
inizializzazione : 
lock = 0; /*lock è una variabile condivisa dai processi vale 0 se nessuno sta eseguendo all'interno della sezione critica, 1 altrimenti*/

per entrare in sezione critica : 

while (lock == 1) /*Attendi*/;
lock = 1;  //Attesa attiva (busy waiting) --> si attende usando CPU

in uscita dalla sezione critica : lock = 0

Attenzione --> la procedura per entrare in sezione critica è essa stessa una sezione critica. può succedere : 
  - due processi valutano in pseudoparallelo [lock == 1]
  - entrambi la trovano falsa e ed eseguono [lock = 1]
  - entrmabi entrano nella sezione critica

Soluzione dei problemi di sincronizzazione con busy waiting :
                    L'istruzione test and set lock (TSL)
strada è sfruttare l'aiuto dell'hardware, torniamo all'idea di utilizzare una variabile "lock" condivisa --> come atomica (indivsibile) la sequenza di azioni che effettua il test sul suo valore e poi 
la imposta a 1, ci si fa fornire dall'hw una istruzione di LINGUAGGIO MACCHINA 
                                                                      TSL registro, variabile
Atomicamente opera sul registro e sulla variabile in memoria : 
    1. copia variabile in registro (poi essere testato)
    2. impsota variabile a 1 (Set)
la TSL deve riservre il bus emantenerlo finchè non sono concluse sia la lettura che la scrittura della variabile.

L'istruzione Test and Set lock (TSL)
la TSL può essere usata nel modo seguente per garantire la mutua esclusione
Vista in un linguaggio ad altro livello, essere utilizzata come segue per garantire la mutua eslcusione delle sezioni critiche di n processi :

inizializzazione :  lock = 0
per entrare in sezione critica : 
      while(TestAndSet(&Lock)); //busy waiting
  in uscita dalla sezione critica : 
  lock = 0;

Non soddisfa il requistito di attesa limitata


Problemi di sincronizzazione
l'esecuzione in mutua esclusione di sezioni critiche :  non èl'unico tipo di problema di sincronizzazione tra processi
Esempi di problemi :
      - Gestire la condivisione di un pool di N risorse  fra due o più processi/thread : ogni  p./t. deve chiedere di acquisire
        una risorsa prima di utilizzarla solo dopo che l'acaquisizione é andata a buon fine, rilasciarla nel momento in cui 
        l'utilizzo é concluso 
      - Garantire che la porzione di codice A di P1 sia eseguita prima delle porzioni di codice B di p2
      - Garantire che N threads completino tutti una prima fase di esecuzione prima di poter passare a una seconda fase

Problema del produittore consumatore
il classico problema del produttore e consumatore incorpora diversi problemi di sincronizzazione :
    la necessita di ordinare correttaemnte le attività dei due processi e di far attendere un processo quando non sono disponibili
    risorse
                     _ _ _ _ _ _ _ _ _ _ _ _ _ _
    produttore --->  | | | | | | | | | | | | | |   --> Consumatore
                     - - - - - - - - - - - - - - 
                        Buffer (n porzioni)

il produttore può inserire dati nel buffer solo se esistono posizioni vuote [poassimo considerare le pozioni disponibili nel buffer
come risorse].
il consumatore può prelevare dati dal buffer solo se il buffer contiene dati non acnora prelevati

Astraioni per la sincronizzazione 
Soluzioni basate su varibaili di lock e istruzioni come test-and-set-lock