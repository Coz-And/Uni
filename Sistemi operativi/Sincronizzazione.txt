Sincronizzazione e comunicazione fra processi /thraed
  per realizzare applicazioni costrituite da più processi o thread cooperanti occorrono meccanismi per : 
      1. Attivazione e terminazione di proecsi / thread
      2. Sincronizzazione : p1 per andare avanti attende che p2 sia arrivato ad un dato punto [utile per disciplinare l'accesso a dati condivisi]
      3. Comunicazione : p2 passa dati a p1 [Tipicamente attende anche nella siconizzazione "Semplice" c'è almeno il passaggio dell'informazione che p2 é arrivato al punto desiderato]
  
  I meccanismi si possono trovare in :
  a. linguaggi concorrenti [dotati di istruzioni apposite per attivare e far sincronizzare / comunicare più processi / thread]
  b. system calls messe a disposizione dal sistema operativo
  c. librerie di funzioni per lo sviluppo di applicazioni concorrenti 


  Modello a memoria condivisa : i processi condividono almeno alcune variabili in memoria, se un processo /thread modifica una di queste variabili, 
  gtutti gli altri processi/thread vedanno il nuovo valore . la condivisione é naturale per threads, per i processi é stata introdotta con meccanismi
  appositi.

  Modello a scambio di messaggi  : i processi non condivisono aree di memoeria, ma possono inviarsi messaggi utilizzando istruzioni sed e receive. lo scambio di messaggi :
  i processi. 


  Sezioni critiche : requisiti per una buona soluzione 
  Una soluzione soddisfacente al problema della mutua esclusione di sezioni critiche deve rispettare i seguenti requisiti : 
    a. Mutua Esclusione se il processo Pi é in esecuzione nella propria sezione critica, nessun altro processo può essere in esecuzione nella propria sezione critica
    b. Progresso se nessun processo è in esecuzione nella propria sezioni critica, e vi sono dei processi che intendono entrare nelle rispettive sezioni critiche, la 
       scelta su chi può procedere dipende solo da quali sono questi ultimi processi, e questa scelta non può essere rimandata indefinitamente.
    c. Attesa limitata un processo Pi ha richiesto di entrare in sezione critica, esiste un limite massimo al numero di volte per cui viene consentito ad altri proessi di 
       entrare nelle rispettive sezioni critiche prima che si accordi l'accesso a pi.

si Assume che ogni processo rimanga in sezione critica per un tempo finito, fare alcuna assunzioni sulla velocità relativa dei processi.

Formulazione Alternativa dei requisiti di una buona soluzione  é  : 
  1. essere garantita la mutua eslcusione nell'esecuzione delle sezioni critiche da parte di tutti i processi coinvolti.
  2. non può basarsi su ipotesi rigurado alle velocità relative di esecuzione dei processi coinvolti e al numero di CPU.
  3. processo che sta eseguendo sezioni non critiche non deve impedire ad altri processi di accedere alla propria sezione critica.
  4. non può accedere che un processo debba attendere indefinitamente il proprio turno di entrare in sezione critica.

  Soluzione dei problemi di mutua eslcusione in sezione critica
  Disibilitazione interrupt
  il motivo per le istruzioni che compongono le sezioni critiche di due processi eseguiti in pseudo-parallelismo possono essere intercalate in modo arbitrario è un processo può 
  essere interrotto durante l'esecuzione, causa dell'arrivo di un timer interrupt.

  problemi di questa soluzione :
  - motivi di protezione non si vuole permettere ad un processo che gira in modalità utnete di disabilitare gli interrupt
  - la soluzione funziona correttamente solo se il sistema ha un'unica CPU : nei sistemi multiprocessore la disabilitazione degli interrupt è locale a ciascuna CPU, e i processi 
    possono eseguire davvero in parallelo.

Non-soluzione dei problemi di sincronizzazione 
inizializzazione : 
lock = 0; /*lock è una variabile condivisa dai processi vale 0 se nessuno sta eseguendo all'interno della sezione critica, 1 altrimenti*/

per entrare in sezione critica : 

while (lock == 1) /*Attendi*/;
lock = 1;  //Attesa attiva (busy waiting) --> si attende usando CPU

in uscita dalla sezione critica : lock = 0

Attenzione --> la procedura per entrare in sezione critica è essa stessa una sezione critica. può succedere : 
  - due processi valutano in pseudoparallelo [lock == 1]
  - entrambi la trovano falsa e ed eseguono [lock = 1]
  - entrmabi entrano nella sezione critica

Soluzione dei problemi di sincronizzazione con busy waiting :
                    L'istruzione test and set lock (TSL)
strada è sfruttare l'aiuto dell'hardware, torniamo all'idea di utilizzare una variabile "lock" condivisa --> come atomica (indivsibile) la sequenza di azioni che effettua il test sul suo valore e poi 
la imposta a 1, ci si fa fornire dall'hw una istruzione di LINGUAGGIO MACCHINA 
                                                                      TSL registro, variabile
Atomicamente opera sul registro e sulla variabile in memoria : 
    1. copia variabile in registro (poi essere testato)
    2. impsota variabile a 1 (Set)
la TSL deve riservre il bus emantenerlo finchè non sono concluse sia la lettura che la scrittura della variabile.

L'istruzione Test and Set lock (TSL)
la TSL può essere usata nel modo seguente per garantire la mutua esclusione
Vista in un linguaggio ad altro livello, essere utilizzata come segue per garantire la mutua eslcusione delle sezioni critiche di n processi :

inizializzazione :  lock = 0
per entrare in sezione critica : 
      while(TestAndSet(&Lock)); //busy waiting
  in uscita dalla sezione critica : 
  lock = 0;

Non soddisfa il requistito di attesa limitata


Problemi di sincronizzazione
l'esecuzione in mutua esclusione di sezioni critiche :  non èl'unico tipo di problema di sincronizzazione tra processi
Esempi di problemi :
      - Gestire la condivisione di un pool di N risorse  fra due o più processi/thread : ogni  p./t. deve chiedere di acquisire
        una risorsa prima di utilizzarla solo dopo che l'acaquisizione é andata a buon fine, rilasciarla nel momento in cui 
        l'utilizzo é concluso 
      - Garantire che la porzione di codice A di P1 sia eseguita prima delle porzioni di codice B di p2
      - Garantire che N threads completino tutti una prima fase di esecuzione prima di poter passare a una seconda fase

Problema del produittore consumatore
il classico problema del produttore e consumatore incorpora diversi problemi di sincronizzazione :
    la necessita di ordinare correttaemnte le attività dei due processi e di far attendere un processo quando non sono disponibili
    risorse
                     _ _ _ _ _ _ _ _ _ _ _ _ _ _
    produttore --->  | | | | | | | | | | | | | |   --> Consumatore
                     - - - - - - - - - - - - - - 
                        Buffer (n porzioni)

il produttore può inserire dati nel buffer solo se esistono posizioni vuote [poassimo considerare le pozioni disponibili nel buffer
come risorse].
il consumatore può prelevare dati dal buffer solo se il buffer contiene dati non acnora prelevati

Astraioni per la sincronizzazione 
Soluzioni basate su varibaili di lock e istruzioni come test-and-set-lock sono adeguate solo per alcuni problemi di sincronizzazione semplici, sono eccessivamente di "basso livello"
sviluppare applicazioni concorrenti [più thread o più processi che cooperano o che devono coordinarsi nell'uso di risorse condivise] sono utili meccanismi più di alto livello

opportuno cercare di eliminare introducendo operazioni sospensive 
Vedremo : 
    a. Semafori
    b. Mutex nei Pthreads (posix Threads)

Problemi del busy waiting : l'inversione di priorità 
Il busy waiting deve essere evitato nei limiti del possibile perché :
    1. spreca tempo di CPU [il processo / thread che attende é ready/running e se la CPU é una sola la condizione non può cambiare fino a che non viene data ad un altro processo/thread]
    2. nel cosi di processore singolo può verificarsi il problem dell'inversione di priorità :
        due processi P1 e P2, dove P1 ha priorità su P2 [tra P1 e P2 lo scheduler scegli sempre P1, lo scheduler sceglie tra i processi pronti, non si occupa di sincornizzazione e non
        non va certo a vedere il codice per accorgersi che stanno facendo attesa attiva]

un'idea per evitare busy waiting : sleep e wakeup
Evitare il busy waiting si introducono due system call con la seguente funzione : 
  - Un processo esegue una sleep viene sospeso
  - qualcuno non lo sveglia con una wakeup
  - wakeup non ha alcun effetto se eseguito su un processo non bloccato.

si possono immaginare due varianti di sleep e wakeup : 
   - la prima variante sleep non ha parametri e wakeup ha un unico parametro, l'id del processo da svegliare.

       P1 :                             P2:
       ......                           ........
       Sleep ()                         Wakeup(p1)
       .....                            ........

nella seconda variante sleep deve specificare l'identificatore di una "condizione di attesa" cond, alla quale farà riferimento anche la wakeup; se più processi possono essere in attesa su 
cond occorre definire se la wakeup deve svegliarne sono uno o sveglierli tutti : 


       P1 :                             P2:
       ......                           ........
       Sleep (cond)                     Wakeup(cond)
       .....                            ........


problema del produttore consumatore (P-C)
     il produttore può inserire dati nel buffer solo se esistono posizoni vuote 
     il consumatore può prelevare dati dal buffer solo se il buffer non é completamente vuoto 

                     _ _ _ _ _ _ _ _ _ _ _ _ _ _
    produttore --->  | | | | | | | | | | | | | |   --> Consumatore
                     - - - - - - - - - - - - - - 
                        Buffer (n porzioni)
    
  Utilizzo di Sleep
     se non vi sono posizioni vuote il produttore attende
     se non vi sono prozioni piene il consumatore attende
  Utilizzo di wakeup
    il produttore svelgia il consumatore bloccato in attesa di un dato 
    il consumatore svelgia il produttore bloccato in attesa di uno spazio libero

non-soluzione del problema P-c

  Void producer(void)                                             void consumer(void)
  {                                                                 {
    while(true){                                                      int item;
    item = produce_item();                                             while(true){
    if (count == N) sleep()                                              if (count == 0) sleep()
    insert_item(item)                                                    item = remuove_item()
    count ++;                                                            count --;
    if (count == 1)                                                      if (count == n -1) wakeup(producer)
    wakeup(consumer);                                                    process_item(item)
   }                                                                       } 
 }                                                                        }
  
le operazioni che inseriscono/prelevano effettivamente i dati nel/dal buffer condiviso sono insert_item e remove_item, il buffer può essere un vettore in cui due indici, scorrono cirolamente

Errore

  Void producer(void)                                             void consumer(void)
  {                                                                 {
    while(true){                                                      int item;
    item = produce_item();                                             while(true){
    if (count == N) sleep()                                              if (count == 0) sleep()
    insert_item(item)                                                    item = remuove_item()
    count ++;                                                            count --;
    if (count == 1) wakeup(consumer);                                    if (count == n -1) wakeup(producer)
                                                                         process_item(item)
   }                                                                       } 
 }                                                                        }

 se :
 - il consumatore ha trovato count == 0 e sta per eseguire sleep ()
 - appena prima di eseguirla viene interrotto (dal timer)
 - Viene schedulato il produttore che inserisce un item, incrementa count, ed essendo count == 1 esegue wakeup(consumer)

quest'ultima non ha effetto dato che il consumatore non é bloccato, questo punto il consumatore esegue sleep() e va dormire per sempre
 se eseguiamo un wakeup ad ogni inserimento, si possono raggiungere situazioni non desiderate, ad esempio il produttore procuce un numero limitato di dati, l'ultimo dei quali indica al consumatore
 che il lavoro é concluso, e proprio quest'ultimo viene perso, il consumatore rimane sospeso in eterno.
