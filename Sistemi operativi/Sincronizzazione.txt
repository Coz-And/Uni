Sincronizzazione e comunicazione fra processi /thraed
  per realizzare applicazioni costrituite da più processi o thread cooperanti occorrono meccanismi per : 
      1. Attivazione e terminazione di proecsi / thread
      2. Sincronizzazione : p1 per andare avanti attende che p2 sia arrivato ad un dato punto [utile per disciplinare l'accesso a dati condivisi]
      3. Comunicazione : p2 passa dati a p1 [Tipicamente attende anche nella siconizzazione "Semplice" c'è almeno il passaggio dell'informazione che p2 é arrivato al punto desiderato]
  
  I meccanismi si possono trovare in :
  a. linguaggi concorrenti [dotati di istruzioni apposite per attivare e far sincronizzare / comunicare più processi / thread]
  b. system calls messe a disposizione dal sistema operativo
  c. librerie di funzioni per lo sviluppo di applicazioni concorrenti 


  Modello a memoria condivisa : i processi condividono almeno alcune variabili in memoria, se un processo /thread modifica una di queste variabili, 
  gtutti gli altri processi/thread vedanno il nuovo valore . la condivisione é naturale per threads, per i processi é stata introdotta con meccanismi
  appositi.

  Modello a scambio di messaggi  : i processi non condivisono aree di memoeria, ma possono inviarsi messaggi utilizzando istruzioni sed e receive. lo scambio di messaggi :
  i processi. 


  Sezioni critiche : requisiti per una buona soluzione 
  Una soluzione soddisfacente al problema della mutua esclusione di sezioni critiche deve rispettare i seguenti requisiti : 
    a. Mutua Esclusione se il processo Pi é in esecuzione nella propria sezione critica, nessun altro processo può essere in esecuzione nella propria sezione critica
    b. Progresso se nessun processo è in esecuzione nella propria sezioni critica, e vi sono dei processi che intendono entrare nelle rispettive sezioni critiche, la 
       scelta su chi può procedere dipende solo da quali sono questi ultimi processi, e questa scelta non può essere rimandata indefinitamente.
    c. Attesa limitata un processo Pi ha richiesto di entrare in sezione critica, esiste un limite massimo al numero di volte per cui viene consentito ad altri proessi di 
       entrare nelle rispettive sezioni critiche prima che si accordi l'accesso a pi.

si Assume che ogni processo rimanga in sezione critica per un tempo finito, fare alcuna assunzioni sulla velocità relativa dei processi.

Formulazione Alternativa dei requisiti di una buona soluzione  é  : 
  1. essere garantita la mutua eslcusione nell'esecuzione delle sezioni critiche da parte di tutti i processi coinvolti.
  2. non può basarsi su ipotesi rigurado alle velocità relative di esecuzione dei processi coinvolti e al numero di CPU.
  3. processo che sta eseguendo sezioni non critiche non deve impedire ad altri processi di accedere alla propria sezione critica.
  4. non può accedere che un processo debba attendere indefinitamente il proprio turno di entrare in sezione critica.

  Soluzione dei problemi di mutua eslcusione in sezione critica
  Disibilitazione interrupt
  il motivo per le istruzioni che compongono le sezioni critiche di due processi eseguiti in pseudo-parallelismo possono essere intercalate in modo arbitrario è un processo può 
  essere interrotto durante l'esecuzione, causa dell'arrivo di un timer interrupt.

  problemi di questa soluzione :
  - motivi di protezione non si vuole permettere ad un processo che gira in modalità utnete di disabilitare gli interrupt
  - la soluzione funziona correttamente solo se il sistema ha un'unica CPU : nei sistemi multiprocessore la disabilitazione degli interrupt è locale a ciascuna CPU, e i processi 
    possono eseguire davvero in parallelo.

Non-soluzione dei problemi di sincronizzazione 
inizializzazione : 
lock = 0; /*lock è una variabile condivisa dai processi vale 0 se nessuno sta eseguendo all'interno della sezione critica, 1 altrimenti*/

per entrare in sezione critica : 

while (lock == 1) /*Attendi*/;
lock = 1;  //Attesa attiva (busy waiting) --> si attende usando CPU

in uscita dalla sezione critica : lock = 0

Attenzione --> la procedura per entrare in sezione critica è essa stessa una sezione critica. può succedere : 
  - due processi valutano in pseudoparallelo [lock == 1]
  - entrambi la trovano falsa e ed eseguono [lock = 1]
  - entrmabi entrano nella sezione critica

Soluzione dei problemi di sincronizzazione con busy waiting :
                    L'istruzione test and set lock (TSL)
strada è sfruttare l'aiuto dell'hardware, torniamo all'idea di utilizzare una variabile "lock" condivisa --> come atomica (indivsibile) la sequenza di azioni che effettua il test sul suo valore e poi 
la imposta a 1, ci si fa fornire dall'hw una istruzione di LINGUAGGIO MACCHINA 
                                                                      TSL registro, variabile
Atomicamente opera sul registro e sulla variabile in memoria : 
    1. copia variabile in registro (poi essere testato)
    2. impsota variabile a 1 (Set)
la TSL deve riservre il bus emantenerlo finchè non sono concluse sia la lettura che la scrittura della variabile.

L'istruzione Test and Set lock (TSL)
la TSL può essere usata nel modo seguente per garantire la mutua esclusione
Vista in un linguaggio ad altro livello, essere utilizzata come segue per garantire la mutua eslcusione delle sezioni critiche di n processi :

inizializzazione :  lock = 0
per entrare in sezione critica : 
      while(TestAndSet(&Lock)); //busy waiting
  in uscita dalla sezione critica : 
  lock = 0;

Non soddisfa il requistito di attesa limitata


Problemi di sincronizzazione
l'esecuzione in mutua esclusione di sezioni critiche :  non èl'unico tipo di problema di sincronizzazione tra processi
Esempi di problemi :
      - Gestire la condivisione di un pool di N risorse  fra due o più processi/thread : ogni  p./t. deve chiedere di acquisire
        una risorsa prima di utilizzarla solo dopo che l'acaquisizione é andata a buon fine, rilasciarla nel momento in cui 
        l'utilizzo é concluso 
      - Garantire che la porzione di codice A di P1 sia eseguita prima delle porzioni di codice B di p2
      - Garantire che N threads completino tutti una prima fase di esecuzione prima di poter passare a una seconda fase

Problema del produittore consumatore
il classico problema del produttore e consumatore incorpora diversi problemi di sincronizzazione :
    la necessita di ordinare correttaemnte le attività dei due processi e di far attendere un processo quando non sono disponibili
    risorse
                     _ _ _ _ _ _ _ _ _ _ _ _ _ _
    produttore --->  | | | | | | | | | | | | | |   --> Consumatore
                     - - - - - - - - - - - - - - 
                        Buffer (n porzioni)

il produttore può inserire dati nel buffer solo se esistono posizioni vuote [poassimo considerare le pozioni disponibili nel buffer
come risorse].
il consumatore può prelevare dati dal buffer solo se il buffer contiene dati non acnora prelevati

Astraioni per la sincronizzazione 
Soluzioni basate su varibaili di lock e istruzioni come test-and-set-lock sono adeguate solo per alcuni problemi di sincronizzazione semplici, sono eccessivamente di "basso livello"
sviluppare applicazioni concorrenti [più thread o più processi che cooperano o che devono coordinarsi nell'uso di risorse condivise] sono utili meccanismi più di alto livello

opportuno cercare di eliminare introducendo operazioni sospensive 
Vedremo : 
    a. Semafori
    b. Mutex nei Pthreads (posix Threads)

Problemi del busy waiting : l'inversione di priorità 
Il busy waiting deve essere evitato nei limiti del possibile perché :
    1. spreca tempo di CPU [il processo / thread che attende é ready/running e se la CPU é una sola la condizione non può cambiare fino a che non viene data ad un altro processo/thread]
    2. nel cosi di processore singolo può verificarsi il problem dell'inversione di priorità :
        due processi P1 e P2, dove P1 ha priorità su P2 [tra P1 e P2 lo scheduler scegli sempre P1, lo scheduler sceglie tra i processi pronti, non si occupa di sincornizzazione e non
        non va certo a vedere il codice per accorgersi che stanno facendo attesa attiva]

un'idea per evitare busy waiting : sleep e wakeup
Evitare il busy waiting si introducono due system call con la seguente funzione : 
  - Un processo esegue una sleep viene sospeso
  - qualcuno non lo sveglia con una wakeup
  - wakeup non ha alcun effetto se eseguito su un processo non bloccato.

si possono immaginare due varianti di sleep e wakeup : 
   - la prima variante sleep non ha parametri e wakeup ha un unico parametro, l'id del processo da svegliare.

       P1 :                             P2:
       ......                           ........
       Sleep ()                         Wakeup(p1)
       .....                            ........

nella seconda variante sleep deve specificare l'identificatore di una "condizione di attesa" cond, alla quale farà riferimento anche la wakeup; se più processi possono essere in attesa su 
cond occorre definire se la wakeup deve svegliarne sono uno o sveglierli tutti : 


       P1 :                             P2:
       ......                           ........
       Sleep (cond)                     Wakeup(cond)
       .....                            ........


problema del produttore consumatore (P-C)
     il produttore può inserire dati nel buffer solo se esistono posizoni vuote 
     il consumatore può prelevare dati dal buffer solo se il buffer non é completamente vuoto 

                     _ _ _ _ _ _ _ _ _ _ _ _ _ _
    produttore --->  | | | | | | | | | | | | | |   --> Consumatore
                     - - - - - - - - - - - - - - 
                        Buffer (n porzioni)
    
  Utilizzo di Sleep
     se non vi sono posizioni vuote il produttore attende
     se non vi sono prozioni piene il consumatore attende
  Utilizzo di wakeup
    il produttore svelgia il consumatore bloccato in attesa di un dato 
    il consumatore svelgia il produttore bloccato in attesa di uno spazio libero

non-soluzione del problema P-c

  Void producer(void)                                             void consumer(void)
  {                                                                 {
    while(true){                                                      int item;
    item = produce_item();                                             while(true){
    if (count == N) sleep()                                              if (count == 0) sleep()
    insert_item(item)                                                    item = remuove_item()
    count ++;                                                            count --;
    if (count == 1)                                                      if (count == n -1) wakeup(producer)
    wakeup(consumer);                                                    process_item(item)
   }                                                                       } 
 }                                                                        }
  
le operazioni che inseriscono/prelevano effettivamente i dati nel/dal buffer condiviso sono insert_item e remove_item, il buffer può essere un vettore in cui due indici, scorrono cirolamente

Errore

  Void producer(void)                                             void consumer(void)
  {                                                                 {
    while(true){                                                      int item;
    item = produce_item();                                             while(true){
    if (count == N) sleep()                                              if (count == 0) sleep()
    insert_item(item)                                                    item = remuove_item()
    count ++;                                                            count --;
    if (count == 1) wakeup(consumer);                                    if (count == n -1) wakeup(producer)
                                                                         process_item(item)
   }                                                                       } 
 }                                                                        }

 se :
 - il consumatore ha trovato count == 0 e sta per eseguire sleep ()
 - appena prima di eseguirla viene interrotto (dal timer)
 - Viene schedulato il produttore che inserisce un item, incrementa count, ed essendo count == 1 esegue wakeup(consumer)

quest'ultima non ha effetto dato che il consumatore non é bloccato, questo punto il consumatore esegue sleep() e va dormire per sempre
 se eseguiamo un wakeup ad ogni inserimento, si possono raggiungere situazioni non desiderate, ad esempio il produttore procuce un numero limitato di dati, l'ultimo dei quali indica al consumatore
 che il lavoro é concluso, e proprio quest'ultimo viene perso, il consumatore rimane sospeso in eterno.


meccanismo di sicnronizzazione : i semafori 
il semaforo é un tipo di dato astratto con associate le operazioni che in peseudo-c possiamo descrivere cosi  : 
 - init (semaphore *sp, int val_ini);
 - up (Semaphore *sp)
 - down (Semaphore *sp)

 inidhciamo con s.val il valore [intero non negativo] di un semaforo s, che va inizializzato con init, il valore si può modificare solo attraverso le procedure up e down che si comportano nel modo 
 seguente : 
  1. down : se s.val > 0, tale valore viene decrementato, altrimenti il processo / thread che esegue l'operazione deve attendere 
  2. up : se vi sono processi / thread in attesa per effetto di una down, uno di questi termina l'attesa e conclude l'esecuzione delle down, altrimenti s.val viene incrementato

  up e down devono essere Operazioni Atomiche 

  Up e Down : 
  altri nomi usati in alcuni testi per queste funzioni sono : 
  - signal-waiting
  - V e P, dall'olandese Verhogn = incrementare  e Proberen = verificare, perché i semafori sono stati inventati da wdseger W. dijkstra

  per garantire l'esecuzione in muta esclusione di sezione critiche, può utilizzare un semaforo s, inizializzato a 1 e condiviso da tutti i processi  / thread che contengono sezioni critiche relative a determianrte strutture dati 

  down(&s);
  Sezione Critica 
  up(&s);

  Verde per l'ingresso in sezione critica : vale 1 
  Rosso Vale 0 

  un processo che vuole entrare in sezione critica (down(&S)) :
  1. trova il semaforo verde, lo imposta a rosso ed entra, 
  2. se lo trova rosso viene sospeso

  il rpocesso esce dalla sezione critica (up) il semaforo torna verde se non ci sono processi in attesa, se ve ne sono uno può entrare.


i semfaori implementazione  : 
per una possibile realizzazione come chiamate di sistema, indichiamo con s.queue la lista di processi  /thread associata a s

down(&s):
  if (s.val == 0)
    {
      inserisci il processo corrente p in s.queue;
      cambia stato di p a bloccato 
      scheduler(); dispatcher();
    }
    else s.val--
up(&s)
  if (s.queue non vuota)
  {
    estrai un processo p da s.queue;
    cambia stato di p a pronto 
  } 
   else s.val++


/*non é detto che s.queue sia gestita first-in-first out, il moto più semplice per garantire attesa limitata, e il più neutrale, non sapendo per cosa viene usato il semaforo, non ha senso realizzare un politica dentro a up()*/

I semafori implementazione 
una possibile realizzazione come chiamate di sistema, indichiamo con s.queue la lista di processi / thread associata a s 
down(&s):
  if (s.val == 0)
    {                                                       down indivisibile : evita ad es. che con s.val == 1 due processi  <<vedano>> s.val > 0 e procedano (violando mutua esclusione)
      inserisci il processo corrente p in s.queue;
      cambia stato di p a bloccato 
      scheduler(); dispatcher();
    }
    else s.val--


up(&s)
  if (s.queue non vuota)
  {                                       Estraggono e mettono pronto lo stesso processo, un altro rimane inutilmente sospeso (chiamato anche viola progresso)
    estrai un processo p da s.queue;
    cambia stato di p a pronto 
  } 
   else s.val++

Semafori come System call
la up () e la down() potrebbero essere implementate all'interno del sistema operativo, come system call, per garantire che essa vengono eseguite in modo atomico, su un sistema uniproecssore si può usare la tecnica della disabilitazione degli interrupt , su un sistem amultiprocessore,
si può usare la soluzione al problema della mutua eslcusione basato sulla istruzione TSL.
l'attesa attiva in questo caso può essere accettabile poiché la sezione al problema della mutua eslcusioen basato sulla istruzione TSL.
l'attesa attiva in questo caso può essere accettabile poiché la sezione critica é molto breve: i processi  / thread girano su processori diversi, uno fa attesa ttiva al massimo per il tempo necessario agli altri per eseguire il codice della uo o della down 
consiste in poche istruzioni, a differenza di quello di una sezione critica che inserisce chi scrive i programmi che usano up / down no é limitata.

Nota su semafori e programmazioni 
esempi tratti dal testo i semafori sono dichiarti cosi  : 
  typedef int semaphore;
  semaphore mutex = 1

la notazione è usata solo per anologia ocn il C : 
 vero che come indica un commento " i semafori sono un tipo speciale di interi", ma il loro essere speciali consiste nell'essere messe a disposizione dal sistema operativo, insieme con le oeprazioni predefinite (down e up) realizzate attraverso chiamate di sistema
 é opportuo che non si possa operare in altro modo sui semafori.
 Utilizzando il nome della variabile in istruzione di assegnazione, sono stati realizzati dei linguaggi per la programmazione concorrente in cui esiste veramente un tipo "semaphore" e il compilatore interagisce con il sistema oeprativo.

 Semafori binari o semafori contatore
 un semaforo binario può assumere solo i valori 0 o 1, le stesse operazioni gia viste, ma nel caso si tratti di un vero e proprio semafori inario, se si esegue una up () quando s.val  è gia 1, questa non ha alcun effetto.
 possono essere utilizzati per garantire la mutua eslcusione, inizializzando a 1, se usati solo atale scopo possono essere chiamati mutex, eventualemtne con inizializzazione implicita.

 é un semaforo binario anche quello usato per "B in Pk solo dopo A in Pi" inizializzato a 0 

un Semaforo contatore può assumere qualsiasi valore =>0 può essere usato ad esmepio per il problema di sicronizzazione con un numero N di risorse da assegnare : 
inizializza a N, numero di "risorse" disponibile 
  preleva = down(&s)
  rilascia = up(&s)

N processi / thread possono superare down senza nessuna up, l'n+1 esimo viene sospeso, in ogni momento s.val => 0, e vale : 
    s.val = N -numero down completate + numero up completate, cioè, intendendolo come numero di "risorse" disponibile : 
              risorse totali - risorse prelevate +  risorse rilasciate

Nota su semafori e programmazioni 

Esempi 
Typedef int semaphore;
sempahore mutex = 1 

la nostazione è suata solo per anologia con il C:
vero che indica un commento "i semafori sono un tipo speciale di interi", ma il loro essere speciali consiste nell'essere strutture che devono essere messe a disposizione dal sistema operativo, insieme con le operazioni prefeinite (down e up) realizzate attraverso chiamate di sistema,
é opportuno che non si possa operare in altro modo sui semafori, Esempio --> utilizzando il nome della variabile in istruzioni di assegnazione. 
sono stati realizzati dei linguaggi per la programmazione concorrente in cui esiste veramente un tipo "semaphore" e il compilatore interagisce ocn il sistema operativo.


Semafori binari o semafori contatore
Un semaforo binario può assumere solo i valori 0 o 1, le stesse operazioni gia viste; ma nel caso si tratti di un vero e proprio semaforo binario, se si esegue una up () quando s.val gia 1, questa non ha è indefinito,
meglio scrivere i programmi in modo che non succeda, perché le conseguenze sono a scelta.

possono essere utilizzati per garantire la mutua esclusione, inizializzandoli a 1, s eusati solo a tale scopo possono essere chiamati mutex, eventualemnte con inizializzazione implicita.


Ma è un semaforo binario anche quello usato epr "B in Pk solo dopo A inPi", va inizializzato a 0 
un semaforo contatore può assumere qualsiasi valore =>0, può essere usato 

Esempio 
il problema di sincronizzazione con un numero N di risorse da assegnare : 
  si inizializza a N, numero di "risorse" disponibili 
  preleva = down(&s)
  rilascia = up(&s)
N processi  / threads possono superare down senza nessuna up, l'N+1 esimo viene sospeso, in ogni momento s.val é =>0 

      s.val = N - numero down completate + numero up completate
  cioè, intendendolo com e numero di "risorse" disponibili : 
        risorse totali - risorse prelevate + risorse rilasciate

problemi di sincronizzazione : il deadlock (Stallo)

Deadlock (Stallo) --> si verifica quando due o più processi attendono indefinitamente il verificarsi di un evento che può essere causato solo da uno dei processi stessi 

Problemi di sincronizzazione:

La starvation 
Starvation (morte di fame), si verifica quando un processo P rimane per sempre in una coda d'attesa, altri processi vengono ripetutamente risvelgiati prima di P.
Se la coda venisse gestita con polita LIFO (Last in First Out) é possibile che un processo rimanga in coda.

Dining Philosophers
I filosofi pensano, ma ogni tanto mangiano, per mangiare necessitano di 2 forchette, quella alla propria sinistra e quella propria destra, rappresenta, il caso di vari processi che per parte del loro codice, non devono sincronizzarsi per un'altra devono 
utilizzare più risorse in mutau eslcusione.

#define N 5                         /*numero di filosofi*/

void philosopher (int i)            /*i :  filosofo numero, da 0 a 4 */
{
  wile(TRUE){                       
    think ();                       /*richiesta filosofi*/
    take_fork(i);                   /*Richiesta della forchetta sinistra*/
    take_fork((i+1) %N);            /*Richiesta della forchetta destra, % operatore modulo*/
    eat();
    put_fork(i);                    /*Rimetti la forchetta sinistra sul tavolo*/
    put_fork((i+1) %N);             /*Rimetti la forchetta destra sul tavolo*/
  }
}

può portare ad una situazione di deadlock --> se tutti i filosofi prelevano la forchetta di sinistra e poi si sospendono attendono di acquistare la forhcetta di destra, rimarranno bloccati in questo stato indefinitamente

riprendiamo la definiszione di deadlock :
 un insieme di processi in attesa di un evento che può essere provocato solo da un processo nell'insieme stesso, in questo caso 

 il filosofo 0 supera la down(&fork[0]) ma rimane sospeso sulla down(&Fork[1]),
 il filosofo 1 supera la down(&fork[1]) ma rimane sospeso sulla down(&fork[2]),
  ...,
  il filosofo N supera la down(&fork[N]) ma rimane sospeso sulla
  down(&fork[0])
  --> Ciclo di N processi in attesa

  il filosofo 0 attende la forchetta che può essere liberata solo dal filosofo1, il quale attende la forchetta che può essere liberata solo dal filoso 2, ... il filosofo 4, il quale attende la forchetta che può essere
  liberata solo dal filosofo 0, i cinque processi formano un ciclo di attesa dal quale non si può uscire.

  Dinig Philosophers
  Una possibile soluzione consiste nel cambiare l'ordine di acquisizione delle forhcette ad un dei filosfi : 
  Esempio : 
  il filosofo 4 potrebbe acquisire prima la forchetta di destra (0) e poi di sinistra (4)

  un'altra possibile soluzione consiste nell'ammenttere al più 4 filosfi nella fase di acquisizione forchette, utilizzando un semaforo contatore inizializzato a 4, e aggiungendo down(&count) prima dell'acquisizione delle forchette ed una up(&count) subito
  dopo l'acquisizione di entrambe le forchette.
  Una terza soluzione possibile consiste nell'acquisire le risorse contemporaneamente, anzichèuna alla volta. Usiamo un array di N semafori s[n].
  quando il processo i non può acquisire le forchette, si sospende sul semaforo s[i], quando un semaforo viene usato in questo modo, si chiama semaforo privato.

  Politche di assegnazione risorse tramite semafori privati 
  i semafori privati sono tali solo per come vengono usati : il meccanismo messo a disposizione dalle funzioni è lo stesso, senza alcun controllo su quale processo / thread usa i semafori e come


    1. un semaforo privato s_priv_P un processo P è inizializzato a 0
    2. Solo il processoP, la Esegue quando deve attendere che diventi vera una condizione di sincornizzazione 
    3. Qualsiasi processo può eseguire up(&s_priv_P) se serve svegliare P, o serve non farlo sospendere se fa down, perché é vera la condizione di sincronizzazione.

Codice :

#define N              5                    
#define LEFT           ((i+N-1)%N)
#define RIGHT          ((i+1)%N)
#define THINKING       0
#define HUNGRY         1
#define EATING         2
typedef int semaphore
int states[n]
semaphore mutex = 1
sempahore s[n]

void philosopher (int i)
{
  while (true){
    think();
    take_forkS(i);
    eat();
    put_fork(i);
  }
  void take_forcks(int i)
  {
    down(&mutex);
    state[i] = HUNGRY;
    test(LEFT);
    test(RIGHT);
    ip(&mutex);
  }
  void put_forks(i)
  {
    down(&mutex)
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex)
  }
  void test(i)
  {
    if (state[i] == HUNGRY && state[LEFT] != EATING && state [RIGHT] != EATING){
      state[i] = EATING
      up(&s[i])
    }
  }
}
 
LA soluzione può essere elaborata per garantire l'assenza di stravation: 
non permettono ad un filoso di mangiare più di k volte di fila se un suo vicino è affamato : 
- ogni volta che il filosofo i preleva la forchetta che serve anche a un vicino affamato si incrementa un contatore
- il contatore arriva  ak il filosofo si sospende.

